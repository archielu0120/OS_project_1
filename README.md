# report

# 設計
## 架構
使用兩顆CPU 來達成排程效果。 CPU 0 負責 schedule  ， CPU 1 負責跑task 。 在讀進資料後， 先作排序 ， 並在  CPU 0 跑迴圈作計時。 當達到執行條件時 ， fork 出一個 child process 並使用 sched_setaffinity() 將其送到   CPU  1 。 每個process 能擁有3種 priiority  。 在一開始被 fork 的時候是 MID_PRIOR 且馬上被設為 LOW_PRIOR 。 在 waiting list 前端準備要被執行的時候設為 MID_PRIOR 。 執行中的 process 為 HIGH_PRIOR 。 而當某個 child process 結束可以讓出 CPU 的時候 ， 利用 SIGCHLD 通知 parent process 自己已經結束了。

### FIFO
實作下最直觀的FIFO ， ㄧ開始將input 照ready time 排序。
``` c=
check_and_assign_priority() {
    if(CPU 1 is occupied  &&  there exist waiting process) {
        set first process in waiting list to MID_PRIOR
    }
    if(CPU 1 is not occupied && there exist waiting process) {
        set first process in waiting list to HIGH_PRIOR (i.e. run that process)
    }
}
```
```
sched_fifo {

    Sort()     //By ready time
    
    WAIT ALL CHILD
    
    while(! all task has finished){    // 

        check_and_assign_priority();    //check CPU 1 's state and a    ssign new priority for waiting queue
    
        wihle(exist new ready process){
            fork_child();
            check_and_assign_priority();
        }
    
        unit_time();
    }
 }
```

### RR
用一個 first in first out queue q 把 waiting process 放到裡面。  在parent process 設一個 clock ， 當clock ==  TIME_SLICE 的時候 ，把running process  set  LOW_PRIOR 。 並將他一到 q 的尾巴。

```
check_and_assign_priority() {
    if(CPU 1 is occupied  &&  there exist waiting process) {
        set first process in waiting list to MID_PRIOR
    }
    if(CPU 1 is not occupied && there exist waiting process) {
        set first process in waiting list to HIGH_PRIOR (i.e. run that process)
    }
```
```
sched_rr {

    Sort();    //By ready time
    
    WAIT ALL CHILD
    
    whilie(! all task has finished) {
        check_and_assiign_priority();
        while(exist ready process) {
            fork_child();
            push it into q
            check_and_assign_priority();
        }
        count++;
        uniit_time();
        if(count == TIME_SLICE && CPU 1 is occupied) {
            burst_time of running process -= TIME_SLICE;
            pop running process from q
            set running process LOW_PRIOR
            push it back to q
            Ocuupied = false
            check_and_assign_priority();
        }
    }
}
```
### SJF
SJF 中 在某個時間點有一個新的process ready 了 並且 CPU 1 剛好被釋放。 這時 waiting list 的 first process 不一定是最優先的（因為最新ready process 的 burst time 可能更小 )  。 因此， 先將waiting list 中 first process set LOW_PRRIOR （decrease_next() ) ， 並將最新 ready process 插入 min heap 中做更新 。 如此操作完之後才能保證是 SJF 。

```
check_and_assign_priority() {
    if(CPU 1 is occupied  &&  there exist waiting process) {
        set first process in waiting list to MID_PRIOR
    }
    if(CPU 1 is not occupied && there exist waiting process) {
        set first process in waiting list to HIGH_PRIOR (i.e. run that process)
    }
```
```
sched_sjf {

    Sort();      //By burst time  
    Sort();     //By ready time
    
    WAIT ALL CHILD
    
    while(! all task has finished){    

        check_and_assign_priority();    
    
        wihle(exist new ready process){
            decrese_next();
            fork_child();
            insert new ready process into min heap
            check_and_assign_priority();
        }
    
        unit_time();
    }
```
### PSJF
PSJF 中 min heap 裡的root 不是first waiting 而是running process 。  因為 preemtive ， 所以只要有新的ready process ， running process 與 first waiting 就要更新一次，並且在丟入min heap 比較。 另外 ， 為了避免 race condition 可以用 sigprocmask 去 block SIGCHLD 。
```
decrease_priority() {
    if(CPU 1 is not occupied && root)
    running = root;
    burst time of running -= counting
    counting = 0;
    pop root from min heap;
    if (root) 
        set root to LOW_PRIOR
    set running to LOW_PRIOR
    insert running back to min heap
    
}

```

```
check_and_assign_priority() {
    if(CPU 1 is occupied  &&  there exist waiting process) {
        set first process in waiting list to MID_PRIOR
    }
    if(CPU 1 is not occupied && there exist waiting process) {
        set first process in waiting list to HIGH_PRIOR (i.e. run that process)
    }
```
```
sched_psjf {

    Sort();      //By burst time  
    Sort();     //By ready time
    
    WAIT ALL CHILD
    
    while(! all task has finished){    

        check_and_assign_priority();    
    
        wihle(exist new ready process){
            decrese_priority();
            fork_child();
            insert new ready process into min heap
            check_and_assign_priority();
        }
        counting++;
        unit_time();
    }
```


# 環境

|       Platform        | Programming Language | OS    |     Kernel     |
|:---------------------:|:--------------------:| ----- |:--------------:|
| VirtualBox 6.0 on Mac |          C          | Linux | Ubuntu 4.14.25 |




# 結果 ＆誤差分析
## Time Measurement
時間單位：sec
**The average time of 500 unit_time(): 0.7395**
```
FIFO
10
P0 0 500
P1 1000 500
P2 2000 500
P3 3000 500
P4 4000 500
P5 5000 500
P6 6000 500
P7 7000 500
P8 8000 500
P9 9000 500
```
![](https://i.imgur.com/OeUaZoK.png)

## FIFO
### FIFO_1
**Input:**
```
FIFO
5
P1 0 500
P2 0 500
P3 0 500
P4 0 500
P5 0 500
```
**Output:**
```
P1 2237
P2 2238
P3 2239
P4 2240
P5 2241
[ 1609.062524] [Project1] 2237 1588077669.025571276 1588077669.793490025
[ 1609.827305] [Project1] 2238 1588077669.793988343 1588077670.558271745
[ 1610.588877] [Project1] 2239 1588077670.558763827 1588077671.319843578
[ 1611.346794] [Project1] 2240 1588077671.320389341 1588077672.077758750
[ 1612.108156] [Project1] 2241 1588077672.078257512 1588077672.839122703
```
理論：3.6975
結果：3.8135
誤差：0.116 (3%)

### FIFO_2
**Input:**
```
FIFO
4
P1 0 80000
P2 100 5000
P3 200 1000
P4 300 1000
```
**Output:**
```
P1 1910
P2 1911
P3 1912
P4 1913
[  178.864733] [Project1] 1910 1588078242.103213835 1588078358.646366827
[  186.175069] [Project1] 1911 1588078358.646875570 1588078365.956701018
[  187.646940] [Project1] 1912 1588078365.957208551 1588078367.428574634
[  189.117353] [Project1] 1913 1588078367.429034323 1588078368.898984911
```
理論：128.673
結果：126.7957
誤差：1.8872 (1.4%)

### FIFO_3
**Input:**
```
FIFO
7
P1 0 8000
P2 200 5000
P3 300 3000
P4 400 1000
P5 500 1000
P6 500 1000
P7 600 4000
```
**Output:**
```
P1 2041
P2 2042
P3 2043
P4 2044
P5 2045
P6 2046
P7 2047
[  544.471194] [Project1] 2041 1588078712.331766331 1588078724.252827437
[  551.946439] [Project1] 2042 1588078724.253317723 1588078731.728071982
[  556.412072] [Project1] 2043 1588078731.728658399 1588078736.193706560
[  557.909178] [Project1] 2044 1588078736.194310899 1588078737.690812269
[  559.405765] [Project1] 2045 1588078737.691596803 1588078739.187398312
[  560.929509] [Project1] 2046 1588078739.187862950 1588078740.711142696
[  566.897585] [Project1] 2047 1588078740.711630225 1588078746.679218339

```
理論：34.017
結果：34.3475
誤差：0.3305 (0.9%)

### FIFO_4
**Input:**
```
FIFO
4
P1 0 2000
P2 500 500
P3 500 200
P4 1500 500

```
**Output:**
```
P1 2010
P2 2011
P3 2012
P4 2013
[  349.843971] [Project1] 2010 1588079551.334628899 1588079554.252537685
[  350.584525] [Project1] 2011 1588079554.253169993 1588079554.993088911
[  350.889061] [Project1] 2012 1588079554.993758501 1588079555.297627488
[  351.638328] [Project1] 2013 1588079555.298293587 1588079556.046896331
```
理論：4.7328
結果：4.7122
誤差：0.0205 (0.4%)

### FIFO_5
**Input:**
```
FIFO
7
P1 0 8000
P2 200 5000
P3 200 3000
P4 400 1000
P5 400 1000
P6 600 1000
P7 600 4000
```
**Output:**
```
P1 2091
P2 2092
P3 2093
P4 2094
P5 2095
P6 2096
P7 2097
[  608.776814] [Project1] 2091 1588079801.267148289 1588079813.185382258
[  616.255856] [Project1] 2092 1588079813.185918297 1588079820.664422020
[  620.741626] [Project1] 2093 1588079820.665031701 1588079825.150194379
[  622.238422] [Project1] 2094 1588079825.150700616 1588079826.646990092
[  623.736445] [Project1] 2095 1588079826.647508413 1588079828.145013136
[  625.233020] [Project1] 2096 1588079828.145490506 1588079829.641587634
[  631.218272] [Project1] 2097 1588079829.642070238 1588079835.626839730
```
理論：34.017
結果：34.3597
誤差：0.3427 (1%)











## RR
### RR_1
**Input:**
```
RR
5
P1 0 500
P2 0 500
P3 0 500
P4 0 500
P5 0 500
```
**Output:**
```
P1 1919
P2 1920
P3 1921
P4 1922
[   85.748003] [Project1] 1919 1588074686.786990173 1588074687.536134918
[   86.495459] [Project1] 1920 1588074687.536671800 1588074688.283592602
[   87.237608] [Project1] 1921 1588074688.284017367 1588074689.025741140
[   87.973563] [Project1] 1922 1588074689.026165420 1588074689.761696332
[   88.716574] [Project1] 1923 1588074689.762118963 1588074690.504704623
```
理論：3.6975
結果：3.7177
誤差：0.0202 (0.5%)

### RR_2
**Input:**
```
RR
2
P1 600 4000
P2 800 5000
```
**Output:**
```
P1 2017
P2 2018
[  476.267783] [Project1] 2017 1588075066.707814430 1588075078.055915196
[  478.553418] [Project1] 2018 1588075067.477019111 1588075080.341550043
```
理論：13.311
結果：13.6337
誤差：0.3227 (2.4%)

### RR_3
**Input:**
```
RR
6
P1 1200 5000
P2 2400 4000
P3 3600 3000
P4 4800 7000
P5 5200 6000
P6 5800 5000
```
**Output:**
```

P1 1899
P2 1900
P3 1901
P4 1902
P5 1903
P6 1904
[   80.265494] [Project1] 1901 1588076120.238167957 1588076140.996461189
[   81.577435] [Project1] 1899 1588076115.772843223 1588076142.308401281
[   82.996944] [Project1] 1900 1588076118.008319351 1588076143.727909062
[   94.515030] [Project1] 1904 1588076126.172344776 1588076155.245997393
[   97.281773] [Project1] 1903 1588076124.694842228 1588076158.012739170
[   98.538552] [Project1] 1902 1588076123.197405467 1588076159.269518968
```
理論：44.37
結果：43.4967
誤差：0.8733 (2%)


### RR_4
**Input:**
```
RR
7
P1 0 8000
P2 200 5000
P3 300 3000
P4 400 1000
P5 500 1000
P6 500 1000
P7 600 4000
```
**Output:**
```
P1 2043
P2 2044
P3 2045
P4 2046
P5 2047
P6 2048
P7 2049
[  511.047428] [Project1] 2046 1588076565.456899987 1588076571.778393016
[  512.562114] [Project1] 2047 1588076567.085856937 1588076573.293081326
[  513.310999] [Project1] 2048 1588076567.872353616 1588076574.041963922
[  524.907284] [Project1] 2045 1588076564.695881399 1588076585.638249895
[  530.809260] [Project1] 2049 1588076568.688863551 1588076591.540226724
[  532.967110] [Project1] 2044 1588076563.938857723 1588076593.698075555
[  537.278691] [Project1] 2043 1588076563.177656334 1588076598.009658365
```
理論：34.017
結果：34.0708
誤差：0.0538 (0.1%)

### RR_5
**Input:**
```
RR
7
P1 0 8000
P2 200 5000
P3 200 3000
P4 400 1000
P5 400 1000
P6 600 1000
P7 600 4000
```
**Output:**
```
P1 2139
P2 2140
P3 2141
P4 2142
P5 2143
P6 2144
P7 2145
[ 1058.430890] [Project1] 2142 1588077113.097672588 1588077119.161856240
[ 1059.173236] [Project1] 2143 1588077113.868989646 1588077119.904201678
[ 1060.682166] [Project1] 2144 1588077115.390465466 1588077121.413132243
[ 1071.771851] [Project1] 2141 1588077112.330645190 1588077132.502817217
[ 1077.658039] [Project1] 2145 1588077116.153850794 1588077138.389006811
[ 1079.758081] [Project1] 2140 1588077111.564289089 1588077140.489048710
[ 1084.027297] [Project1] 2139 1588077110.780957259 1588077144.758263992
```
理論：34.017
結果：33.9773
誤差：0.0397 (0.1%)










## SJF

### SJF_1
**Input:**
```
SJF
4
P1 0 7000
P2 0 2000
P3 100 1000
P4 200 4000
```
**Output:**
```
P2 1923
P3 1925
P4 1930
P1 1924
[   90.621304] [Project1] 1923 1588072569.466391930 1588072572.450700489
[   92.142348] [Project1] 1925 1588072572.451203954 1588072573.971746882
[   98.185690] [Project1] 1930 1588072573.972223901 1588072580.015089506
[  108.473073] [Project1] 1924 1588072580.015560132 1588072590.302471618
```

理論：20.706
結果：20.8361
誤差：0.1301 (0.6%)

### SJF_2
**Input:**
```
SJF
5
P1 100 100
P2 100 4000
P3 200 200
P4 200 4000
P5 200 7000
```
**Output:**
```
P1 1861
P3 1862
P2 1862
P4 1864
P5 1865
[   75.295843] [Project1] 1861 1588073420.842098025 1588073420.995784955
[   75.597140] [Project1] 1863 1588073420.996399460 1588073421.297083988
[   81.843325] [Project1] 1862 1588073421.297534768 1588073427.543268801
[   88.072398] [Project1] 1864 1588073427.543733188 1588073433.772340669
[   98.778682] [Project1] 1865 1588073433.772822273 1588073444.478625334
```
理論：22.628
結果：23.6365
誤差：1.008 (4.4%)



### SJF_3
**Input:**
```
SJF
8
P1 100 3000
P2 100 5000
P3 100 7000
P4 200 10
P5 200 10
P6 300 4000
P7 400 4000
P8 500 9000
```
**Output:**
```
P1 2102
P4 2105
P5 2106
P6 2107
P7 2108
P2 2103
P3 2104
P8 2109
[  434.221904] [Project1] 2102 1588071863.395440444 1588071868.001839607
[  434.237279] [Project1] 2105 1588071868.002304826 1588071868.017215642
[  434.253426] [Project1] 2106 1588071868.017710757 1588071868.033361827
[  440.144537] [Project1] 2107 1588071868.033868383 1588071873.924472523
[  445.997298] [Project1] 2108 1588071873.925015571 1588071879.777234360
[  453.762275] [Project1] 2103 1588071879.777863617 1588071887.542209517
[  464.679228] [Project1] 2104 1588071887.542777361 1588071898.459163134
[  478.748774] [Project1] 2109 1588071898.459659775 1588071912.528709431
```
理論：47.3576
結果：49.1332
誤差：1.7756 (3.7%)

### SJF_4
**Input:**
```
SJF
5
P1 0 3000
P2 1000 1000
P3 2000 4000
P4 5000 2000
P5 7000 1000
```
**Output:**
```
P1 2829
P2 2830
P3 2831
P5 2835
P4 2834
[ 5790.719442] [Project1] 2829 1588060355.701984353 1588060360.172931394
[ 5792.214498] [Project1] 2830 1588060360.173420110 1588060361.667985497
[ 5798.186511] [Project1] 2831 1588060361.668473339 1588060367.640002276
[ 5799.647051] [Project1] 2835 1588060367.640509845 1588060369.100541014
[ 5802.567661] [Project1] 2834 1588060369.100998971 1588060372.021151847
```
理論：16.2703
結果：16.3192
誤差：0.0489 (0.3%)

### SJF_5
**Input:**
```
SJF
4
P1 0 2000
P2 500 500
P3 1000 500
P4 1500 500
```
**Output:**
```
P1 2997
P2 2998
P3 2999
P4 3000
[ 6987.703475] [Project1] 2997 1588061554.166856864 1588061557.156959857
[ 6988.458300] [Project1] 2998 1588061557.157471757 1588061557.911787668
[ 6989.202597] [Project1] 2999 1588061557.912311667 1588061558.656086782
[ 6989.953071] [Project1] 3000 1588061558.656538925 1588061559.406561750
```
理論：5.1765
結果：5.2397
誤差：0.0632 (0.1%)




## PSJF

### PSJF_1
**Input:**
```
PSJF
4
P1 0 10000
P2 1000 7000
P3 2000 5000
P4 3000 3000
```
**Output:**
```
P1 1914
P2 1921
P3 1929
P4 1930
[   85.877903] [Project1] 1930 1588070659.392616579 1588070663.770712315
[   91.599074] [Project1] 1929 1588070657.910478816 1588070669.491884026
[  100.130159] [Project1] 1921 1588070656.401754933 1588070678.022967871
[  113.183790] [Project1] 1914 1588070654.896427709 1588070691.076600092
```
理論：36.975
結果：36.180
誤差：0.0737 (2%)

### PSJF_2
**Input:**
```
PSJF
5
P1 0 3000
P2 1000 1000
P3 2000 4000
P4 5000 2000
P5 7000 1000
```
**Output:**
```
P1 1932
P2 1947
P3 1948
P4 1950
P5 1951
[   84.831358] [Project1] 1947 1588071517.058980937 1588071518.611291971
[   87.750029] [Project1] 1932 1588071515.548377651 1588071521.529965490
[   92.154624] [Project1] 1950 1588071522.993512906 1588071525.934559504
[   93.619207] [Project1] 1951 1588071525.946830191 1588071527.399143013
[   97.874626] [Project1] 1948 1588071521.530457161 1588071531.654563815
```
理論：16.269
結果：16.106
誤差：0.1628 (1%)

### PSJF_3
**Input:**
```
PSJF
4
P1 0 2000
P2 500 500
P3 1000 500
P4 1500 500
```
**Output:**
```
P1 1882
P2 1883
P3 1884
P4 1888
[   434.221904] [Project1] 2102 1588071863.395440444 1588071868.001839607
[   434.237279] [Project1] 2105 1588071868.002304826 1588071868.017215642
[   434.253426] [Project1] 2106 1588071868.017710757 1588071868.033361827
[   440.144537] [Project1] 2107 1588071868.033868383 1588071873.924472523
[   445.997298] [Project1] 2108 1588071873.925015571 1588071879.777234360
[   453.762275] [Project1] 2103 1588071879.777863617 1588071887.542209517
[   464.679228] [Project1] 2104 1588071887.542777361 1588071898.459163134
[   478.748774] [Project1] 2109 1588071898.459659775 1588071912.528709431
```
理論：5.1765
結果：5.2037
誤差：0.0272 (0.5%)

### PSJF_4
**Input:**
```
PSJF
4
P1 0 7000
P2 0 2000
P3 100 1000
P4 200 4000
```
**Output:**
```
P2 3498
P3 3500
P4 3501
P1 3499
[10168.316176] [Project1] 3500 1588064736.257775371 1588064737.769666397
[10171.158336] [Project1] 3498 1588064736.094333940 1588064740.611826998
[10177.160474] [Project1] 3501 1588064740.612331206 1588064746.613963504
[10187.420527] [Project1] 3499 1588064746.614421416 1588064756.874016330
```
理論：20.706
結果：20.7797
誤差：0.0737 (0.4%)

### PSJF_5
**Input:**
```
PSJF
5
P1 100 100
P2 100 4000
P3 200 200
P4 200 4000
P5 200 7000
```
**Output:**
```
P1 2292
P3 2294
P2 2293
P4 2295
P5 2296
[  868.687778] [Project1] 2292 1588070036.261729445 1588070036.413264473
[  868.989896] [Project1] 2294 1588070036.413762371 1588070036.715370763
[  881.017014] [Project1] 2295 1588070036.720982216 1588070048.742500533
[  881.178262] [Project1] 2293 1588070036.716561195 1588070048.903752229
[  891.367881] [Project1] 2296 1588070048.904173400 1588070059.093367577
```
理論：22.628
結果：22.8316
誤差：0.203 (0.8%)

## 可能造成誤差的原因：
1. 設計上為schedule 和 task 在不同 CPU 上跑。 就算在同一顆 CPU 上跑每次unit_time() 都不同，在不同 CPU 上誤差可能會越大。
2. 照理來說，實作下CPU排程還需要處理資料結構等程式本身問題，可能會造成超時的誤差。然而，數據中發現有負的誤差，這表示系統本身也可能會有context switch 之類等等自身運作上的成本。 因此， 實驗當時的 CPU 負載狀況也是影響結果重要的因素之一。
